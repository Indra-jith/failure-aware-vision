<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description"
        content="Architecture visualization of the Failure-Aware Vision Trust pipeline ‚Äî from sensor input to policy gating.">
    <title>Architecture ‚Äî Vision Trust Platform</title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="/js/three.min.js"></script>
    <script src="https://unpkg.com/lenis@1.1.20/dist/lenis.min.js"></script>
</head>

<body>

    <!-- Floating lines background (fixed, behind all content) -->
    <div id="floatingLinesBg" class="page-floating-bg"></div>

    <nav class="nav" role="navigation" aria-label="Main navigation">
        <a href="/" class="nav-brand" aria-label="Vision Trust ‚Äî Home">
            <div class="nav-brand-icon" aria-hidden="true">FV</div>
            <span class="nav-brand-text">Vision Trust</span>
            <span class="nav-brand-sub">Research Platform</span>
        </a>

        <button class="nav-hamburger" id="navHamburger" aria-label="Toggle menu" aria-expanded="false"
            aria-controls="navLinks">
            <span></span><span></span><span></span>
        </button>

        <ul class="nav-links" id="navLinks" role="list">
            <li><a href="/" class="nav-link"><span class="nav-icon" aria-hidden="true">‚ö°</span> Simulator</a></li>
            <li><a href="/architecture" class="nav-link active" aria-current="page"><span class="nav-icon"
                        aria-hidden="true">‚óà</span> Architecture</a></li>
            <li><a href="/playground" class="nav-link"><span class="nav-icon" aria-hidden="true">‚¨°</span> Playground</a>
            </li>
        </ul>

        <div class="nav-actions">
            <span class="nav-context-badge">Architecture View</span>
        </div>
    </nav>

    <main class="main-content">

        <div class="page-header fade-in-up">
            <h1>System Architecture</h1>
            <p>Interactive pipeline stack of the failure-aware vision trust system. Scroll down to explore the data flow
                from sensor input to policy gating.</p>
        </div>

        <div class="scroll-stack-scroller fade-in-up">
            <div class="scroll-stack-inner">

                <!-- 1. Input -->
                <div class="scroll-stack-card">
                    <div class="glass-panel">
                        <h2>üì∑ User Input ‚Äî Sensor Source</h2>

                        <div class="detail-section">
                            <h3>Concept</h3>
                            <p>Visual data arrives via the <code>/image_raw</code> Gazebo topic at 30Hz. The web
                                simulation lets you inject hardware-level faults directly (freeze, blank, corruption)
                                prior to processing.</p>
                        </div>

                        <div class="detail-section">
                            <h3>Logic</h3>
                            <pre># ROS2: Camera publishes to /image_raw
# Web: User selects mode via control panel

Input modes:
  normal     ‚Üí  Continuous frame stream
  frozen     ‚Üí  Repeated identical frame
  blank      ‚Üí  Near-zero intensity frame
  corrupted  ‚Üí  Mismatched frame dimensions</pre>
                        </div>

                        <div class="detail-section">
                            <h3>ROS2 Source Mapping</h3>
                            <p><span class="file-ref">üìÅ gazebo_camera_demo/launch/camera_world.launch.py</span></p>
                        </div>


                    </div>
                </div>

                <!-- 2. Vision -->
                <div class="scroll-stack-card">
                    <div class="glass-panel">
                        <h2>üëÅÔ∏è Vision Simulation ‚Äî Frame Generation</h2>

                        <div class="detail-section">
                            <h3>Concept</h3>
                            <p>Generates synthetic frames mimicking real sensors via Canvas configurations: Gaussian
                                noise, brightness shifts, sensor lockup, and packet drops.</p>
                        </div>

                        <div class="detail-section">
                            <h3>Logic</h3>
                            <pre># Frame state classification rules:
if frame == previous_frame:       # diff < 1.0
    status = VISION_FROZEN
elif mean(frame) < 5:
    status = VISION_BLANK
elif frame.shape != expected:
    status = VISION_CORRUPTED
else:
    status = VISION_OK</pre>
                        </div>


                    </div>
                </div>

                <!-- 3. Rule -->
                <div class="scroll-stack-card">
                    <div class="glass-panel">
                        <h2>üõ°Ô∏è Rule-Based Detector ‚Äî Failure Classification</h2>

                        <div class="detail-section">
                            <h3>Concept</h3>
                            <p>The first line of defense. Classifies frames into four states (<strong>OK, FROZEN, BLANK,
                                    CORRUPTED</strong>) via pixel diffs and shape checks. Rules are absolute.</p>
                        </div>

                        <div class="detail-section">
                            <h3>Logic</h3>
                            <pre>def on_image(self, msg):
    status = 'VISION_OK'
    if frame.shape != prev.shape:
        status = 'VISION_CORRUPTED'
    elif abs(frame - prev) < 1.0:
        status = 'VISION_FROZEN'
    elif mean(frame) < 5:
        status = 'VISION_BLANK'</pre>
                        </div>

                        <div class="detail-section">
                            <h3>ROS2 Source Mapping</h3>
                            <p><span class="file-ref">üìÅ failure_aware_ros/image_subscriber.py (lines 73-89)</span></p>
                        </div>


                    </div>
                </div>

                <!-- 4. ML -->
                <div class="scroll-stack-card">
                    <div class="glass-panel">
                        <h2>üß† ML Anomaly Model ‚Äî Autoencoder</h2>

                        <div class="detail-section">
                            <h3>Concept</h3>
                            <p>A Conv-Autoencoder trained on gazebo scenes. Frame reconstruction MSE derives the
                                continuous anomaly score. This is strictly a penalizing signal.</p>
                        </div>

                        <div class="detail-section">
                            <h3>Logic</h3>
                            <pre>class AutoEncoder(nn.Module):
    # Conv2d ‚Üí ReLU ‚Üí ConvTranspose2d

# Inference:
tensor = torch.tensor(img).unsqueeze(0)
recon = model(tensor)
anomaly_score = MSE(recon, tensor)</pre>
                        </div>

                        <div class="detail-section">
                            <h3>ROS2 Source Mapping</h3>
                            <p><span class="file-ref">üìÅ ml_phase1/train_autoencoder.py, ml_phase1/run_inference.py,
                                    failure_aware_ros/image_subscriber.py (lines 99-108)</span></p>
                        </div>


                    </div>
                </div>

                <!-- 5. Trust -->
                <div class="scroll-stack-card">
                    <div class="glass-panel">
                        <h2>‚è±Ô∏è Temporal Trust Engine ‚Äî Core Mathematics</h2>

                        <div class="detail-section">
                            <h3>Concept</h3>
                            <p>Maintains temporal <strong>reliability</strong> ‚àà [0, 1]. Base decay targets physical
                                sensor faults. Leaky ML penalty applies only during VISION_OK.</p>
                        </div>

                        <div class="detail-section">
                            <h3>Logic</h3>
                            <pre>def update(status, anomaly, dt):
    if status == 'VISION_OK':
        reliability += 0.10 * dt
        anomaly_int += anomaly * dt - leak
        reliability -= ml_penalty(anomaly_int)
    else:
        # Strict decay rules
        reliability -= decay_rate[status] * dt
        anomaly_int = 0.0 # ML disabled

    reliability = clamp(reliability, 0, 1)</pre>
                        </div>


                    </div>
                </div>

                <!-- 6. Policy -->
                <div class="scroll-stack-card">
                    <div class="glass-panel">
                        <h2>‚ö° Policy Gating ‚Äî Action Derivation</h2>

                        <div class="detail-section">
                            <h3>Concept</h3>
                            <p>Policy converts the [0,1] confidence into absolute boolean directives mapping to hardware
                                control bounds (ALLOWED, DEGRADED, BLOCKED) via thresholds.</p>
                        </div>

                        <div class="detail-section">
                            <h3>Logic</h3>
                            <pre>def derive_policy(rel):
    if rel >= 0.7: return 'ALLOWED'
    if rel >= 0.3: return 'DEGRADED'
    return 'BLOCKED'
# Fixed bounds. Zero hysteresis overrides.</pre>
                        </div>

                        <div class="detail-section">
                            <h3>ROS2 Source Mapping</h3>
                            <p><span class="file-ref">üìÅ failure_aware_ros/vision_supervisor.py (lines 101-113),
                                    failure_aware_ros/vision_control_guard.py</span></p>
                        </div>


                    </div>
                </div>

                <!-- 7. Logger -->
                <div class="scroll-stack-card">
                    <div class="glass-panel">
                        <h2>üìä Session Logger ‚Äî Data Recording</h2>

                        <div class="detail-section">
                            <h3>Concept</h3>
                            <p>All core state updates (time, status, trust, bounded ML score) export to structured CSV
                                enabling post-run analysis and ROS2 architectural validation.</p>
                        </div>

                        <div class="detail-section">
                            <h3>Logic</h3>
                            <pre># Format tracking ROS2 output
[time, rel, state, anomaly, integral]

# Example write
177074383, 1.0, ALLOWED, 0.019, 0.003
flush() # Immediate write guarantee</pre>
                        </div>

                        <div class="detail-section">
                            <h3>ROS2 Source Mapping</h3>
                            <p><span class="file-ref">üìÅ failure_aware_ros/vision_supervisor.py (lines 62-78, 119-128),
                                    vision_logs/vision_reliability_log.csv</span></p>
                        </div>

                    </div>
                </div>

                <!-- 8. ML Philosophy -->
                <div class="scroll-stack-card">
                    <div class="glass-panel">
                        <h2>ü§ñ How ML is Used</h2>

                        <div class="detail-section">
                            <h3>Context</h3>
                            <p>Throughout the pipeline, the machine learning components (CNN Autoencoder) are strictly
                                isolated from safety-critical decision paths. This ensures the system maintains absolute
                                deterministic control.</p>
                        </div>

                        <div class="detail-section">
                            <h3>Key Principles</h3>
                            <p>
                                ‚Ä¢ <strong>Never Overrides Rules</strong>: ML anomaly scores can mathematically only
                                decrease reliability, never increase it. Hard deterministic safety rules always
                                dominate.<br>
                                ‚Ä¢ <strong>Penalty Signal Only</strong>: The autoencoder output is strictly a bounded
                                penalty term applied to the trust integrator.<br>
                                ‚Ä¢ <strong>Instant Reset</strong>: On any explicit physical failure (camera freeze,
                                signal drop), the ML temporal integration is instantly zeroed.<br>
                                ‚Ä¢ <strong>Explainability</strong>: By mathematically separating the ML anomaly score
                                into an independent continuous variable in the logs, the platform provides full
                                auditability of the AI model's exact influence.
                            </p>
                        </div>
                    </div>
                </div>

                <!-- Spacer so the last pin can release cleanly -->
                <div class="scroll-stack-end"></div>

            </div>
        </div>

    </main>

    <script src="/js/floating-lines.js"></script>
    <script src="/js/scroll-stack.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize the floating lines background
            const bg = document.getElementById('floatingLinesBg');
            if (bg && typeof FloatingLines !== 'undefined' && typeof THREE !== 'undefined') {
                new FloatingLines(bg, {
                    enabledWaves: ['top', 'bottom'],
                    lineCount: 8,
                    lineDistance: 11,
                    bendRadius: 40,
                    bendStrength: -0.3,
                    interactive: false,
                    parallax: false,
                    animationSpeed: 0.6,
                    linesGradient: ['#00f0ff', '#7b2fff', '#ff00aa', '#00f0ff'],
                });
            }

            // Mobile nav toggle
            const hamburger = document.getElementById('navHamburger');
            const navLinks = document.getElementById('navLinks');

            if (hamburger) {
                hamburger.addEventListener('click', () => {
                    const expanded = hamburger.getAttribute('aria-expanded') === 'true';
                    hamburger.setAttribute('aria-expanded', !expanded);
                    navLinks.classList.toggle('active');
                    hamburger.classList.toggle('active');
                });
            }

            // Initialize the ScrollStack animation manually
            new ScrollStack({
                itemDistance: 100,        // Space between cards before stacking
                itemStackDistance: 0,    // Cards stack EXACTLY on top of each other, replacing dimensions
                itemScale: 0,            // NO scaling ‚Äî keep all cards same size
                baseScale: 1,            // Top card always at full size
                stackPosition: '10%',    // Pin higher up so larger cards fit on screen
                useWindowScroll: true
            });
        });
    </script>
</body>

</html>